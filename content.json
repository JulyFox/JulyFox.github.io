[{"title":"CSS知识梳理","date":"2020-03-28T07:31:08.000Z","path":"2020/03/28/CSS知识梳理/","text":"四种CSS样式表的引入方式： 内部样式表 12345&lt;head&gt;&lt;style&gt;h1 &#123;color: yellow;&#125;&lt;/style&gt;&lt;/head&gt; 行内式 1&lt;div style=\"color:red\"&gt;字体红色&lt;/div&gt; 外部样式表 css外部引入的样式，空格也是占内存的 1&lt;link href=\"xxx.css\" rel=\"stylesheet\" type=\"text/css\"&gt; 导入式 123&lt;style type=\"text/css\"&gt; @import \"css文件路径\";&lt;/style&gt; 标签显示模式display 块级元素 1&lt;h1&gt;~&lt;h6&gt; &lt;p&gt; &lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素 不独占区域，靠自身字体大小和图像尺寸支撑结构 1&lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;del&gt; &lt;s&gt; &lt;ins&gt; &lt;span&gt; &lt;u&gt; 行内元素的特点：（1）和相邻行内元素在一行上。（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。（3）默认宽度就是它本身内容的宽度。（4）行内元素只能容纳文本或则其他行内元素。 行内块元素 CSS的三大特性：层叠性、继承性、优先级​ css的继承性：子元素可以继承父元素的样式（text-，font-，line-，color）这类属性 CSS盒子模型（重点）​ CSS盒子由四大部分组成：content padding border margin 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 1盒子的总宽度&#x3D; width+左右内边距之和+左右边框宽度之和+左右外边距之和 1盒子的总高度&#x3D; height+上下内边距之和+上下边框宽度之和+上下外边距之和 CSS3盒模型CSS浮动（重点）CSS定位（重点）重排和重绘","comments":true,"tags":[]},{"title":"JS数据结构——排序算法","date":"2020-03-28T02:38:44.000Z","path":"2020/03/28/JS数据结构——排序算法/","text":"JS排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function ArrayList() &#123; //属性 this.array = []; // 方法：插入数据 ArrayList.prototype.insert = function (item) &#123; this.array.push(item); &#125; // 方法：交换数据 swap ArrayList.prototype.swap = function (i, j) &#123; let temp = this.array[i]; this.array[i] = this.array[j]; this.array[j] = temp; &#125; // 方法：toString ArrayList.prototype.toString = function () &#123; return this.array.join('-'); &#125; // 冒泡排序 ArrayList.prototype.BubbleSort = function () &#123; for (let i = this.array.length-1; i &gt; 0; i--) &#123; for (let j = 0; j &lt; this.array.length; j++) &#123; if(this.array[j] &gt; this.array[j+1] )&#123; this.swap(j,j+1); &#125; &#125; &#125; return this.array; &#125; // 选择排序 ArrayList.prototype.SelectSort = function()&#123; let min; // 外层循环从0开始 for (let j = 0; j &lt; this.array.length-1; j++) &#123; min = j; // 内层循环从：从i+1的位置开始取数据 for (let i = j+1; i &lt; this.array.length; i++) &#123; if(this.array[min] &gt; this.array[i])&#123; min = i; &#125; &#125; this.swap(min,j); &#125; return this.array; &#125; // 插入排序 ArrayList.prototype.InsertSort = function()&#123; let temp; // 一组数 3 4 5 2 1 待插入顺序：3 4 5 2 1 for (let i = 0; i &lt; this.array.length; i++) &#123; let j = i; temp = this.array[i]; while(this.array[j-1]&gt;this.array[j] &amp;&amp; j&gt;0)&#123; this.array[j] = this.array[j-1]; j--; &#125; this.array[j] = temp; &#125; return this.array; &#125; // 希尔排序：是插入排序的高效改进版，效率比插入排序快 ArrayList.prototype.SellSort = function()&#123; let length = this.array.length; let gap = Math.floor(length/2); while(gap &gt;= 1)&#123; for (let i = 0; i &lt; length; i++) &#123; let j = i; let temp = array[i]; while(this.array[j-gap] &gt; temp &amp;&amp; (j-gap)&gt;1)&#123; this.array[j] = this.array[j-gap]; j -= gap; &#125; this.array[j] = temp; &#125; &#125; return this.array; &#125; // 快速排序 // 1选择一个基准元素，将列表分隔成两个子序列 // 2、对列表重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面 // 3、分别对较小元素的子序列和较大元素的子序列重复步骤 ArrayList.prototype.QuickSort =function()&#123; let length = this.array.length; if(length == 0)&#123; return []; &#125; let left = []; let right = []; let pivot = this.array[0]; for (let i = 0; i &lt; length; i++) &#123; if (this.array[i] &lt; pivot) &#123; left.push(this.array[i]); &#125;else&#123; right.push(this.array[i]); &#125; &#125; return QuickSort(left).concat(pivot,QuickSort(right)); &#125;&#125;","comments":true,"tags":[]},{"title":"JS数据结构——二叉树","date":"2020-03-28T02:38:25.000Z","path":"2020/03/28/JS数据结构——二叉树/","text":"JS二叉树定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185class Node &#123; constructor(key) &#123; this.left = null; this.right = null; this.key = key; &#125;&#125;class BinarySearchTree extends Node &#123; constructor(key) &#123; super(key, key); this.root = null; &#125; // 节点插入 // 增 insert(key) &#123; // 1创建节点 // 2判断根节点是否为空 空，此节点插入为根节点 if (this.root == null) &#123; this.root = new Node(key); // console.log(this.root); &#125; // 4不空，与当前节点比较大小 else &#123; this.insertNode(this.root, key); &#125; &#125; insertNode(node, key) &#123; if (node.key &gt; key) &#123; //新节点小于当前节点 寻找左子树 if (node.left == null) &#123; //左子树为空，直接插入 node.left = new Node(key); &#125; else &#123; //左子树不为空，继续递归 this.insertNode(node.left, key); &#125; &#125; else &#123; if (node.right == null) &#123; node.right = new Node(key); &#125; else &#123; this.insertNode(node.right, key); &#125; &#125; &#125; // 查 // 中序遍历 左 根 右 inOrder(callback) &#123; this.inOrderNode(this.root, callback) &#125; inOrderNode(node, callback) &#123; if (node != null) &#123; this.inOrderNode(node.left, callback); callback(node.key); this.inOrderNode(node.right, callback); &#125; &#125; // 先序遍历 根 左 右 preOrder(callback) &#123; this.preOrderNode(this.root, callback); &#125; preOrderNode(node, callback) &#123; if (node != null) &#123; callback(node.key); this.preOrderNode(node.left, callback); this.preOrderNode(node.right, callback); &#125; &#125; // 后序遍历 左 右 根 postOrder(callback) &#123; this.postOrderNode(this.root, callback); &#125; postOrderNode(node, callback) &#123; if (node != null) &#123; this.postOrderNode(node.left, callback); this.postOrderNode(node.right, callback); callback(node.key); &#125; &#125; // 搜索树中的值一般有三种类型：最小值、最大值、特定值 // 搜索最小值 沿着最左边的方向一直 min() &#123; return this.minNode(this.root); &#125; minNode(node) &#123; let current = node; while (current != null &amp;&amp; current.left != null) &#123; current = current.left; &#125; return current; &#125; // 搜索最大值 沿着最右边的方向一直找 max()&#123; return this.maxNode(this.root); &#125; maxNode(node)&#123; let current = node; while(current !=null &amp;&amp; current.right != null)&#123; current = current.right; &#125; return current; &#125; // 搜索一个特定的值 search(key)&#123; return this.searchNode(this.root,key); &#125; searchNode(node,key)&#123; if(node == null)&#123; return false; &#125; if(node.key &gt; key)&#123; return this.searchNode(node.left,key); &#125;else if(node.key &lt; key)&#123; return this.searchNode(node.right,key); &#125;else&#123; return true; &#125; &#125; // 移除一个节点三种情况： // 1、移除叶节点 // 2、移除一个有左侧或者右侧子节点的节点 // 3、移除有两个子节点的节点 // 若要移除一个节点先要找到他，调用search函数 remove(key)&#123; this.root = this.removeNode(this.root,key); &#125; removeNode(node,key)&#123; if(node == null)&#123; return false; &#125; if(node.key &gt; key)&#123; node.left = this.removeNode(node.left,key); return node; &#125;else if(node.key &lt; key)&#123; node.right = this.removeNode(node.right,key); return node; &#125;else&#123; //1 if(node.left == null &amp;&amp; node.right == null)&#123; node = null; return node; &#125; //2 if(node.left == null)&#123; node = node.right; return node; &#125;else if(node.right == null)&#123; node = node.left; return node; &#125; //3 let aux = this.minNode(node.right); node.key = aux.key; node.right = this.removeNode(node.right,aux.key); return node; &#125; &#125;&#125;// 测试let tree = new BinarySearchTree();tree.insert(11);tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25);const printNode = (value) =&gt; console.log(value);tree.inOrder(printNode);tree.preOrder(printNode);tree.postOrder(printNode);console.log(tree.search(9) ? '9 found' : '9 not fouond');console.log(tree.search(1) ? '1 found' : '1 not found');","comments":true,"tags":[]},{"title":"JS数据结构——链表","date":"2020-03-28T02:37:29.000Z","path":"2020/03/28/JS数据结构——链表/","text":"JS链表定义","comments":true,"tags":[]},{"title":"JS数据结构——队列","date":"2020-03-28T02:36:43.000Z","path":"2020/03/28/JS数据结构——队列/","text":"JS队列定义","comments":true,"tags":[]},{"title":"JS数据结构——栈","date":"2020-03-28T02:35:36.000Z","path":"2020/03/28/JS数据结构——栈/","text":"JS栈的定义：栈(Stack)又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地另一端称为栈底。栈是一种后进先出（LIFO）的有序集合。 栈就像在一个桶里放盘子，最上面的盘子就相当于是栈顶，后来的盘子只能放在栈顶（就相当于入栈操作），若要取盘子也只能取最上面的盘子（出栈）。 创建一个基于数组的Stack类12345678910111213141516171819202122232425262728class Stack&#123; constructor()&#123; this.items = []; &#125; push(element)&#123; //向栈添加元素 this.items.push(element); &#125; pop()&#123; //从栈移除元素 this.items.pop(); &#125; peek()&#123; //查看栈顶元素 return this.items[this.items.length - 1]; &#125; isEmpty()&#123; //检查栈是否为空 空为true 不空为false return this.items.length === 0; &#125; clear()&#123; //清空栈元素 this.items = []; &#125; size()&#123; //返回栈里的元素个数 return this.items.length; &#125;&#125;const stack = new Stack();console.log(stack.isEmpty());//输出为truestack.push(1);stack.push(2);console.log(stack.peek());//2 创建一个基于JS对象的Stack类1234567891011121314151617181920212223242526272829303132333435363738394041424344class Stack&#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;; &#125; push(element)&#123; this.items[this.count] = element; this.count++; &#125; size()&#123; return this.count; &#125; isEmpty()&#123; return this.count === 0; &#125; pop()&#123; if(this.isEmpty())&#123; return undefined; &#125; this.count--; let result = this.items[this.count]; delete this.items[this.count]; return result; &#125; peek()&#123; if(this.isEmpty())&#123; return undefined; &#125; return this.items[this.count -1]; &#125; clear()&#123; this.items = &#123;&#125;; this.count = 0; &#125;&#125;new stack = new Stack();stack.push(5);stack.push(3);//对象为键值对形式 //此时items和count//items = &#123;// 0: 5,// 1: 3//&#125;;//count = 2;","comments":true,"tags":[]},{"title":"JS数据结构——数组","date":"2020-03-28T02:28:45.000Z","path":"2020/03/28/JS数据结构——数组/","text":"JS数组的定义数组的标准定义是：一个存储元素的线性集合，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。JS数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可以有不同的类型。数组的元素可以是对象或者是其他数组。 Js的数组是动态的：根据需要会自增或自减，创建时无需声明固定的大小；Js数组也可能数稀疏的：数组元素索引不一定要连续，它们之间可以有空缺。 创建数组1234567var arr = [];//没有元素var arr1 = [2,3.3,\"a\",true];//不同类型元素var n = 1;var arr2 = [n, n+1, n+2];//元素为任意表达式var arr3 = [[1,&#123;x:1,y:2&#125;],[2,&#123;x:3,y:4&#125;]];//元素包含对象var arr4 = [1,,2];//3个元素，1个为undefinedvar arr5 = [,,,]//3个元素都为undefined 存取函数 indexOf() join()和toString() concat()和splice() 可变函数 push()和unshift() pop()和shift() splice() sort()和reverse() 迭代器方法不生成新数组的迭代器方法： forEach() every() some() reduce() 生成新数组的迭代器方法： map() filter() 二维数组和多维数组","comments":true,"tags":[]}]